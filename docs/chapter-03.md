# 第三章 基本概念

## 语法

### 标识符

指变量、函数、属性的名字，或者函数参数。规则如下：

- 第一个字符必须是字母、下划线（_）或者一个美元符号（$）
- 其他字符可以是字母、下划线、美元符号或数字
- 不能把关键字、保留字、`true`、`false`和`null`作为标识符

按照规范，ECMAScript标识符采用驼峰命名法，也就是变量首字母小写，剩下的每个单词的首字母大写。

### 区分大小写

ECMAScript的变量、函数名和操作符都是区分大小写的，变量名 `test` 和变量名 `Test` 分别表示两个不同的变量

### 注释

包括单行注释和块级注释。单行注释以两个斜杠开头，如下所示：

```javascript
// 单行注释
```

块级注释以一个斜杠和一个星号开头`/*`，以一个星号和一个斜杠`*/`结尾，如下所示：

```javascript
/*
 * 这是一个多行
 * （块级）注释
 */
```
### 严格模式

处理一些不确定的行为，对某些不安全的操作抛出错误。启用严格模式，可以在顶部加上如下代码：

```javascript
'use strict'
```

支持严格模式的浏览器包括 IE10+、Firefox 4+、Safari 5.1+、Opera 12+和 Chrome

### 语句

语句以一个分号结尾;如果省略分号，则由解析器确定语句的结尾

虽然条件控制语句（如if语句）只在执行多条语句的情况下才要求使用代码块，但最佳实践是始终在控制语句中使用代码块————即使代码块中只有一条语句

```javascript
if (test) {
    alert(test);
}
```

## 数据类型

有5种简单数据类型（也称作基本数据类型）：`Undefined`、`Null`、`Boolean`、`Number`和`String`。还有一种复杂数据类型————`Object`,`Object`的本质是由一组无序的名值对组成的。

### typeof操作符

typeof用来检测给定变量的数据类型。对一个值使用 `typeof` 操作符可能返回下列某个字符串：

- `undefined` 如果这个值未定义
- `boolean` 如果这个值是布尔值
- `string` 如果这个值是字符串
- `number` 如果这个值是数值
- `object` 如果这个值是对象或 `null`
- `function` 如果这个值是函数

下面是几个使用 `typeof` 操作符的例子：

```javascript
var message = 'some msg';
console.log(typeof message);    // string
console.log(typeof [1,2,3]);    // object
console.log(typeof null);   // object
console.log(typeof Array.prototype.forEach);    // function
```

有些时候， `typeof` 操作符会返回一些令人疑惑的值。比如，调用 `typeof null` 返回了 `object` ，因为特殊值 `null` 被认为是一个空的对象引用

### Undefined类型

使用 `var` 声明变量但未对其加以初始化时，这个变量的值就是 `undefined`

```javascript
var message;
console.log(typeof message);    // undefined
console.log(typeof age);    // undefined
````

### Null类型
null类型是第二个只有一个值的数据类型，这个特殊的值是null。从逻辑角度来看，null值表示一个空对象指针，而这正是 `typeof` 操作符检测 `null` 值会返回 `object` 的原因

如果定义的变量在将来用于保存对象，那么最好将该变量初始化为 `null` 而不是其他值。这样一来，只要直接检查 `null` 值就可以知道相应的变量是否已经保存了一个对象的引用。

实际上， **`undefined` 值是派生自 `null` 值的，因此规定对它们的相等性测试要返回true** 。不过要注意的是，这个操作符出于比较目的会转换其他操作数

```javascript
console.log(undefined == null);     // true
```

### Boolean类型

在代码里面使用最多的一种类型，该类型只有两个字面值： `true` 和 `false` 。这两个值与数字值不是一回事，因此 `true` 不一定等于1，而 `false` 不一定等于0。

需要注意的是， Boolean类型的字面值 `true` 和 `false` 是区分大小写的。也就是说 `True` 和 `False` 都不是布尔值，只是标识符。

要将这个值转换为Boolean类型，可以调用 `Boolean()` ，如下所示：

```javascript
var message = 'Hello world';
console.log( Boolean(message) );  // false
```

下表是各种数据类型及其对应的转换规则，这些规则对理解流控制语句（如if语句）自动执行的Boolean转换非常重要

数据类型     | 转换为true值                | 转换为false值
----------- | -------------------------- | ------------
Boolean     |true                        | false
String      |非空字符串                    | ""（空字符串）
Number      |任何非零数字值（包括无穷大）    | 0或NaN
Object      |任何对象                     |null
Undefined   |N/A                         |undefined

### Number类型

#### 1.浮点数值

由于保存浮点数值需要的内存空间是保存整数值的两倍，因此下面两种情况下ECMAScript会不失时机地将浮点数值转换为整数值。

- 小数点后面没有跟任何数字，如：1.
- 浮点数值本身表示的就是一个整数，如1.0

对于那些极大或极小的数值，可以用e表示法（科学计数法）表示的浮点数值表示。前面是一个数值，中间是一个大写或小写的字母E，后面是10的幂指数，该幂值将用来与前面的数相乘。下面是一个使用e表示法表示数值的例子：

```javascript
var hugeNum = 3.125e7;     // 等于31250000
var miniNum = 3e-17;     // 等于0.00000000000000003
```

对于 **极大数** 来说，在默认情况下，ECMAScript会将那些小数点前面带有21个零以上的数值转换为以e表示法表示的数值。

对于 **极小数** 来说，在默认情况下，ECMAScript会将那些小数点后面带有6个零以上的浮点数值转换为以e表示法表示的数值。

浮点数值的最高精度是17位小数，但在进行算术运算时其精确度远远不如整数，原因：这是使用基于IEEE754数值的浮点计算的通病。例如，0.1加0.2的结果不是0.3，而是0.30000000000000004。因此，永远不要测试某个特定的浮点数值

#### 2.数值范围

ECMAScript能够表示的最小数值保存在 `Number.MIN_VALUE` 中————在大多数浏览器中，这个值是 `5e-324` ；能够表示最大数值保存在 `Number.MAX_VALUE` 中————在大多数浏览器中，这个值是 `1.7976931348623157e+308`。

如果某次计算的结果超出了JS的数值范围，那么这个数值将自动转换成特殊的 `Infinity` 值。如果这个值是负数，则会被转换为 `-Infinity` （负无穷），如果这个值是整数，则会转换为 `Infinity` （正无穷）。

如果某次计算返回了正或者负的 `Infinity` 的值，那么该值就 **无法继续参与下一次计算** 。要确定一个数值是不是有穷的，可以用 `isFinite()` 函数。这个函数在参数位于最小与最大数值之间时会返回 `true` ，如下面的例子：

```javascript
var result = Number.MAX_VALUE + Number.MAX_VALUE;
console.log( isFinite(result) );    // false
```

#### 3.NaN

NaN，即非数值（Not A Number）是用来表示本来要返回数值的操作数未返回数值的情况，这样就不会抛出错误了，主要出现在将字符串解析成数字出错的场合。例如： `5 - 'x' //NaN`

任何数值除以0都会导致错误，从而停止代码的执行。但在JS中，实际上只有0除以0才会返回NaN，正数除以0返回 `Infinity` ，负数除以0返回 `-Infinity` ，因此不会影响代码的执行。

NaN的特点

- 任何涉及 `NaN` 的操作都会返回 `NaN`
    - ```javascript
        NaN + 5  // NaN
    ```
- NaN与任何值都不相等，包括 `NaN` 本身
    - ```javascript
    NaN == NaN   // false
    ```

需要注意的是， `NaN` 不是一个独立的数据类型， 而是一种特殊的数值，它的数据类型依然属于 `Number`, 使用 `typeof` 运算符可以看的很清楚

```javascript
typeof NaN;     // 'number'
````

针对这两个特点定义了 `isNaN()` 函数，这个函数会确定参数是否 “不是数值”。 `isNaN()` 在接收到一个值之后，会尝试将这个值转换为数值。某些不是数值的值会直接转换为数值，例如字符串 `"10"` 或 `Boolean` 值。而任何不能被转换为数值的值都会导致函数返回 `true`。

但对于一个 **空数组** 和 **只有一个数值成员** 的数组， `isNaN` 返回 `false` 。 **内部机制** ：先调用对象的 `valueOf()` 方法，确定是否能转换成数值。如果不能，则基于这个值调用 `toString()` 方法，再返回测试值。

```javascript
isNaN( [] );  // false
isNaN( [789] );   // false
isNaN( ['789'] );     // false
```

因此，判断 `NaN` 更可靠的方法是利用其与任何值都不相等的特性。

```javascript
function myIsNaN(value) {
  return value !== value;
}
```

#### 4.数值转换

- `Number()` 函数，将非数值转换为数值，用于任何数据类型，具体转换规则如下：
    - 如果是 `Boolean` 值， `true` 和 `false` 将分别被转换为1和0
    - 如果是 `null` ，返回0
    - 如果是 `undefined` ，返回 `NaN`
    - 如果是数字型，返回本身
    - 如果是字符串，会忽略前导零，分几种情况
        - 只包含数字，则将其转换为十进制数值
        - 包含有效的浮点格式，则将其转换为对应的浮点数值
        - 包含有效的十六进制格式，则将其转换为对应的十进制格式
        - 字符串是空的，将其转换为0
        - 其余情况返回NaN
    - 如果是对象，则调用对象的 `valueOf()` 方法，然后依照前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的 `toString()` 方法，然后再次依照前面的规则转换返回的字符串值
    
- `parseInt()` 函数，由于 `Number()` 函数在转换字符串时比较复杂而且不够合理，在处理整数时，更常用的是 `parseInt()` 方法
    - 首先会忽略字符串参数的空格，直到找到第一个非空格的字符。若第一个字符不是数字字符或者负号， `parseInt()` 就会返回 `NaN()`
    
     ```javascript
     console.log( parseInt(" 484") );     // 484
     console.log( parseInt("hello world") ); // NaN
     ```
     
    - 若第一个字符是数字字符或者负号，该函数将会继续往下解析，直到解析完后续字符或者遇到了一个非数字字符
    ```javascript
    console.log( parseInt("484haiku") );     // 484
    console.log( parseInt("22.5") );      // 22
    ```
    - 若字符串以"0x"开头且后跟数字字符，这将会被当成一个十六进制整数；如果字符串以"0"开头且后跟数字字符，则会将其当作一个八进制数来解析
    - 实际上 `parseInt()` 的第二个参数可以指定要转换成多少进制的数
    ```javascript
    console.log( parseInt("0xAF", 16) );  // 175
    ```
    
**不指定基数（即第二个参数）** 意味着让 `parseInt()` 决定如何解析输入的字符串，因此为了避免错误的解析，我们建议无论在什么情况下都明确指定的基数

- `parseFloat()` 与前面的 `parseInt()` 类似， 该函数也是从第一个字符开始解析。而且也是一直解析到字符串末尾，或者解析到一个无效的浮点数字符为止。也就是说，字符串中的第一个小数点是有效的，而第二个小数点是无效的
```javascript
console.log( parseFloat("484.44.484") ); // 484.44
```

### String类型

#### 字符字面量

特殊的字符字面量，也叫转义序列，表示非打印字符，或者具有其他用途的字符。

字面量       |   含义
------------|---------
\n          | 换行
\t          | 制表
\b          | 退格
\r          | 回车
\f          | 进纸
\\          | 斜杠

这些字符字面量可以出现在字符串中，而且也被当做一个字符来解析。

#### 字符串的特点

ECMAScript中的字符串是不可变的，字符串一旦创建，它们的值就不能改变。要改变某个变量保存字符串，首先要销毁原来的字符串，然后再用另外一个包含新值的字符串填充该变量，例如：

```javascript
var lang = 'Java';
lang = lang  + 'Script';
```

实现这个操作的过程如下：首先创建一个能容纳10个字符的新字符串，然后在这个字符串中填充 `Java` 和 `Script` ，最后一步是销毁原来的字符串 `Java` 和 字符串 `Script` ，因为这两个字符串已经没用了。这个过程是在后台发生的，而这也是在某些旧版本的浏览器中拼接字符串时速度很慢的原因。但这些浏览器后来的版本已经解决了这个低效率的问题。

#### 转换为字符串

- `toString()` 方法，数值、布尔值、对象和字符串值都有这方法，但null和undefined值没有这个方法。在数值调用 `toString` 方法时可以传递一个参数：输出数值的基数。默认情况下， `toString()` 方法以十进制格式返回数值的字符串表示。而通过传递参数， `toString()` 可以输出以二进制、八进制、十六进制，乃至任何有效进制格式表示的字符串值。如下面的例子：

```javascript
var arr = [1, 2, 3];
arr.toString(); // "1,2,3"

var obj = {a: 1,b: 2};
obj.toString(); // [object Object]

var nullVal = null;
nullVal.toString(); // Uncaught TypeError: Cannot read property 'toString' of null

var num = 10;
alert(num.toString());  // "10"
alert(num.toString(2)); // "1010"
alert(num.toString(8)); // "12"
alert(num.toString(10));    // "10"
alert(num.toString(16));    // "a"
```

- `String()` 方法，在不知道转换值是不是null和undefined的情况下，还可以使用转型函数 `String()` ,这个函数能够将任何类型的值转换为字符串。 `String()` 函数遵循下列转换规则：
    - 如果值有 `toString()` 方法，则调用该方法(没有参数)并返回结果
    - 如果值是 `null` ，则返回 `null`
    - 如果值是 `undefined` ，则返回 `undefined`
    
### Object类型

一组数据和功能的集合，对象可以通过执行 `new` 操作符后跟要创建的对象类型的名称来创建。而创建 `Object` 类型的实例并为其添加属性和方法，就可以创建自定义对象。在JS中如果不给构造函数传递参数，则可以省略后面的那一对圆括号（但是这是不推荐的写法）。

Object类型是所有实例的基础，换句话说，object类型所具有的任何属性和方法也同样存在于更具体的对象中。Object的每个实例都具有下列属性和方法。

- `constructor` ：保存着用于创建当前对象的函数，Object的构造函数就是Object()。
- `hasOwnProperty(propertyName)` ：用于检查给定的属性在当前的对象实例中（而不是在实例的原型链中）是否存在。
- `isPrototypeOf(object)` ：用于检查传入的对象是否是传入对象的原型，看下面的例子：
```javascript
var Person = function() {
  
};

Person.prototype.name = 'haiku';

var person1 = new Person();

Person.prototype.isPrototypeOf(person1);    // true
```
- `propertyIsEnumerable(propertyName)`：用于检查给定的属性是否能够用 `for-in` 语句来枚举。
- `toLocaleString()` ：返回对象的字符串表示，该字符串与执行环境的地区对应
- `toString()` ：返回对象的字符串表示
- `valueOf()` ：返回对象的字符串、数值或布尔值表示。通常与 `toString()` 方法的返回值相同。

## 操作符

### 一元操作符

只能操作一个值的操作符叫做一元操作符。

#### 递增和递减操作符

- 前置型一元操作符：先执行加或者减，再执行下一个运算
- 后置型一元操作符：先执行语句求值，再进行加减

看下面的例子：

```javascript
var num1 = 2;
var num2 = 20;
var num3 = --num1 + num2;   // 21
var num4 = num1 + num2; // 21
```
```javascript
var num1 = 2;
var num2 = 20;
var num3 = num1-- + num2;   // 22
var num4 = num1 + num2; // 21
```

所有这4个操作符对任何值都适用，也就是它们不仅适用于整数，还可以用于字符串、布尔值、浮点数值和对象。应遵循以下原则：
- 在应用于一个包含有效数字字符的字符串时，先将其转换为数字值，再执行加减1的操作。字符串变量变成数字变量
- 在应用于一个不包含有效数字字符的字符串时，将变量的值设置为 `NaN` 
- 在应用于布尔值时，先对 `false` 转换为0，先对 `true` 转换为1，再执行加减1操作
- 在应用于浮点数值时，执行加减1操作
- 在应用于对象时，先调用对象的 `valueOf()` 方法以取得一个可操作的值。然后对该值应用前述规则。如果结果是 `NaN` ，则调用 `toString()` 方法后再应用前述规则。

以下案例展示了上面的规则：

```javascript
var s1 = '2';
var s2 = 'z';
var b = false;
var f = 1.1;
var o = {
    valueOf: function() {
      return -1;
    }
}

s1++;   // 3
s2++;   // NaN
b++;    // 1
f--;    // 0.1000000000009（由于浮点舍入错误所致）
o--;    // -2
```

#### 一元加和减操作符

一元加操作符以一个加号（+）表示，放在数值前面，对数值不会产生任何影响。

不过，在对非数值应用一元加操作符时，该操作符会像[Number()转型函数一样对这个值执行转换](chapter-03.md#4数值转换)

一元减操作符主要用于负数，在将一元减操作符应用于数值时，该值会变成负数。而应用于非数值时，一元减操作符遵循于一元加操作符相同的规则，最后再将得到的数值转换为负数。


### 位操作符

位操作符用于在最基本的层次上，即按内存中表示的数值的位来操作数值。ECMAScript中的所有数值都以IEEE-754 64位格式存储，但位操作符并不直接操作64位的值。而是先将64位的值转换为32位的整数，然后执行操作，最后将结果转换回64位。表面上看起来就好像是在操作32位数值，就跟在其他语言中以类似方式执行二进制操作一样。但这个转换过程也导致了一个严重的副效益，即在对特殊的 `NaN` 和 `Infinity` 值应用位操作时，这两个值都会被当成0来处理。

如果对非数值应用位操作符，会先使用 [`Number()` 函数](chapter-03.md#4数值转换)将该值转换为一个数值，然后再应用位操作

对于有符号的整数，32位中的前31位用于表示整数的值。第32位用于表示数值的符号：0表示正数，1表示负数。这个表示符号的位叫做符号位，符号位的值决定了其他位数值的格式。负数同样以二进制码存储，但使用的格式是二进制补码。计算一个数值的二进制补码，需要经过下列3个步骤：
- 求这个数值绝对值的二进制码（例如，要求-18的二进制补码，先求18的二进制码）
- 求二进制反码，即将0替换为1，将1替换为0
- 得到的二进制反码加1

要根据这三个步骤求得-18的二进制码，首先就要求得18的二进制码，即：

0000 0000 0000 0000 0000 0000 0001 0010

然后，求其二进制反码，即0和1互换：

1111 1111 1111 1111 1111 1111 1110 1101

最后，二进制反码加1：

1111 1111 1111 1111 1111 1111 1110 1110

这样，就求得了-18的二进制表示，即 `11111111111111111111111111101110` 。要注意的是，在处理有符号整数时，是不能访问位31的。

ECMAScript会尽力向我们隐藏所有这些信息。换句话说，在以二进制字符串形式输出一个负数时，我们看到的只是这个负数绝对值的二进制码前面加上了一个负号。如下面例子所示：

```javascript
var num = -18;
num.toString(2);    // -10010
```

#### 1.按位非（NOT）

按位非操作符由一个波浪线 `~` 表示，执行按位非的结果就是返回数值的反码，按位非操作符的本质是：操作符的负值减1。虽然算术运算也能返回同样的结果，但是按位非是在数值最底层执行操作，执行速度更快。看下面的例子：

```javascript
var num1 = 25;      // 二进制 00000000000000000000000000011001
var num2 = ~num1;   // 二进制 11111111111111111111111111100110
alert(num2);        // -26
```

#### 2.按位与（AND）

按位与操作符由一个和号字符（&）表示，它有两个操作符数。从本质上讲，按位与操作就是将两个数值的每一位对齐，简而言之按位与操作只在两个数值的对应位都是1才返回1，任何一位是0，结果都是0。下面看一个对25和3执行按位于操作的例子：

```javascript
var result = 25 & 3;
alert(result);      // 1
```

可见，对25和3执行按位与操作的结果是1。为什么呢，请看其底层操作：

25   = 0000 0000 0000 0000 0000 0000 0001 1001
 3   = 0000 0000 0000 0000 0000 0000 0000 0011
 AND = 0000 0000 0000 0000 0000 0000 0000 0001
 
 
#### 3.按位或（OR）
 
按位或操作符由一个竖线符号（|）表示，同样也有两个操作数，按位与操作在有一个位是1的情况下就返回1，而只有在两个位都是0的情况下才返回0。
 
如果在前面按位于的例子中对25和3执行按位或操作，则代码如下：
 
```javascript
 var result = 25 | 3;
 alert(result);     // 27 
  ```
  
#### 4.按位异或（XOR）

按位异或操作符由一个插入符号（^），也有两个操作数。按位异或与按位或不同之处在于，这个操作在两个数值对应位上只有一个1时才返回1，如果对应的两位都是1或都是0，则返回0。

对25和3执行按位异或操作的代码如下所示：

```javascript
var result = 25 ^ 3;
alert(result);      // 26
```

#### 5.左移

左移操作符由两个小于号（<<）表示，这个操作符会将数值的所有位向左移动指定的位数。例如，如果将数值2（二进制为10）左移动5位，结果就是64（二进制代码1000000），代码如下所示：

```javascript
var oldValue = 2;
var newValue = oldValue << 5;   // 等于二进制的1000000，十进制的64
```

注意，**左移不会影响操作数的符号位**，如果将-2向左移动5位，结果将是-64，而非64。

#### 6.有符号的右移

右移操作符由两个大于号（>>）表示，这个操作符会将数值向右移动，但保留符号位（即正负号标记）。在这过程中遇到空位时，ECMAScript会用**符号位**的值来填充所有空位，有符号的右移操作与左移操作恰好相反，即如果将64向右移动5位，结果将变回2。

#### 7.无符号右移

无符号右移操作符由3个大于号（>>>）表示，这个操作符会将数值的所有32位都向右移动。对正数来说，无符号右移的结果与有符号右移相同。但是对负数来说，情况就不一样了。首先，**无符号右移是以0来填充空位**，而不是像有符号右移那样以符合位的值来填充空位。其次，无符号右移操作符会把负数的二进制码当做正数的二进制码。而且，由于负数以其绝对值的二进制补码形式表示，因此就会导致无符号右移后的结果非常之大。如下面的例子：

```javascript
var oldValue = -64;
var newValue = oldValue >>> 5;
```

